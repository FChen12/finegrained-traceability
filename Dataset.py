import abc, FileUtil, re, logging
from  xml.dom.minidom import parse
from pathlib import Path
from SolutionTraceMatrix import SolutionTraceMatrix

log = logging.getLogger(__name__)

ROOT = Path(__file__).parent
DATASETS = ROOT / "datasets"
LABELED_FOLDER = DATASETS / "labeled"

class Dataset(abc.ABC):
    """
    Subclasses represent the evaluation datasets
    """
    def __init__(self):
        self._num_reqs = FileUtil.count_files(self.req_folder())
        self._num_code = FileUtil.count_files(self.code_folder())
        self._solution_matrix = None
        
    def num_reqs(self):
        return self._num_reqs
    
    def num_code(self):
        return self._num_code
    
    def all_original_code_file_names(self, with_extension=False):
        filenames_with_ext = [name.strip("\n") for name in FileUtil.read_textfile_into_lines_list(self._all_code_filenames_file())]
        if with_extension:
            return filenames_with_ext
        else:
            return [FileUtil.get_filename_without_extension__from_path(filename) for filename in filenames_with_ext]
    
    def all_original_req_file_names(self, with_extension=False):
        filenames_with_ext = [name.strip("\n") for name in FileUtil.read_textfile_into_lines_list(self._all_req_filenames_file())]
        if with_extension:
            return filenames_with_ext
        else:
            return [FileUtil.get_filename_without_extension__from_path(filename) for filename in filenames_with_ext]
        
    def encoding(self):
        return "utf-8-sig"
    @abc.abstractmethod
    def num_original_links(self):
        """
        original number all possible req/code links
        """
        pass
    
    @abc.abstractmethod
    def _all_code_filenames_file(self):
        pass
    
    @abc.abstractmethod
    def _all_req_filenames_file(self):
        pass
    
    @abc.abstractmethod
    def name(self):
        pass
    
    @abc.abstractmethod
    def folder(self):
        pass
    
    @abc.abstractmethod
    def code_folder(self):
        pass
    
    @abc.abstractmethod
    def req_folder(self):
        pass
    
    @abc.abstractmethod
    def method_callgraph(self):
        """
        returns the precalculated method call graph dictionary
        """
        pass
    
    @abc.abstractmethod
    def method_callgraph_path(self):
        pass
    @abc.abstractmethod
    def class_callgraph_path(self):
        pass
    
    def solution_matrix(self):
        if self._solution_matrix is None:
            self._read_solution_matrix()
        return self._solution_matrix
    
    @abc.abstractmethod
    def _read_solution_matrix(self):
        pass
    
    @abc.abstractmethod
    def raw_call_graph_path(self):
        """
        Returns the path to the raw call graph file (generated by an external call graph parser )
        """
        pass
    @abc.abstractmethod
    def packages(self):
        """
        Lists the packages of the dataset.
        (needed for call graph generation to differentiate external classes)
        """
        pass
    @abc.abstractmethod
    def class_callgraph(self):
        pass

class Etour(Dataset):
    ETOUR_FOLDER = DATASETS / "eTour"
    ETOUR_SOLUTION_MATRIX_PATH = ETOUR_FOLDER / "AnswerSet.txt"
    ETOUR_ITAL_SOLUTION_MATRIX_PATH = ETOUR_FOLDER / "AnswerSet_Italian.txt"
    ETOUR_REQ_DIR = ETOUR_FOLDER / "req"
    ETOUR_CODE_DIR = ETOUR_FOLDER / "code"
    ETOUR_RAW_CALLGRAPH = ETOUR_FOLDER / "etour_raw_callgraph.txt"
    ETOUR_CLASS_CALLGRAPH_PATH = ETOUR_FOLDER / "etour_class_callgraph.json"
    ETOUR_METHOD_CALLGRAPH_PATH = ETOUR_FOLDER / "etour_method_callgraph.json"
    ETOUR_ALL_CODE_FILENAMES_FILE = ETOUR_FOLDER / "all_code_filenames.txt"
    ETOUR_ALL_REQ_FILENAMES_FILE = ETOUR_FOLDER / "all_req_filenames.txt"
    
    UC_NAME_TEMPLATE_REGEX = re.compile("^Use case name(:)?", re.RegexFlag.IGNORECASE)
    UC_DESCRIPTION_TEMPLATE_REGEX = re.compile("^Description(:)?", re.RegexFlag.IGNORECASE)
    UC_ACTOR_TEMPLATE_REGEX = re.compile("^Participating Actor(:)?", re.RegexFlag.IGNORECASE)
    UC_PRECONDITION_TEMPLATE_REGEX = re.compile("^Entry (Operator |Tourist )?conditions(:)?", re.RegexFlag.IGNORECASE)
    UC_POSTCONDITION_TEMPLATE_REGEX = re.compile("^Exit conditions(:)?", re.RegexFlag.IGNORECASE)
    UC_QUALI_REQ_TEMPLATE_REGEX = re.compile("^Quality Requirements(:)?", re.RegexFlag.IGNORECASE)
    UC_FLOW_OF_EVENTS_TEMPLATE_REGEX = re.compile("^Flow of events(:)?", re.RegexFlag.IGNORECASE)
    UC_USER_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE) # Should not match anything
    UC_SYSTEM_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE) # Should not match anything
    
    def name(self):
        return "etour"
    
    def folder(self):
        return self.ETOUR_FOLDER
    
    def code_folder(self):
        return self.ETOUR_CODE_DIR
    
    def req_folder(self):
        return self.ETOUR_REQ_DIR
    
    def _all_code_filenames_file(self):
        return self.ETOUR_ALL_CODE_FILENAMES_FILE
    
    def _all_req_filenames_file(self):
        return self.ETOUR_ALL_REQ_FILENAMES_FILE
    
    def num_original_links(self):
        return 6728
    
    def method_callgraph(self):
        return FileUtil.read_dict_from_json(self.ETOUR_METHOD_CALLGRAPH_PATH)
    
    def method_callgraph_path(self):
        return self.ETOUR_METHOD_CALLGRAPH_PATH
    def class_callgraph_path(self):
        return self.ETOUR_CLASS_CALLGRAPH_PATH
    def keys_with_extension(self):
        return False
    
    def _read_solution_matrix(self, req_ext=None, code_ext=None):
        self._solution_matrix = read_txt_format_solution_matrix(self.ETOUR_SOLUTION_MATRIX_PATH)
    
    def italian_solution_matrix(self): # Class names and uc names are italian 
        return read_txt_format_solution_matrix(self.ETOUR_ITAL_SOLUTION_MATRIX_PATH)
    
    def raw_call_graph_path(self):
        return self.ETOUR_RAW_CALLGRAPH
    
    def class_callgraph(self):
        return FileUtil.read_dict_from_json(self.ETOUR_CLASS_CALLGRAPH_PATH)
    
    def packages(self):
        return ["beans", "com.trapan", "unisa.gps"]
    
class Itrust(Dataset):
    
    ITRUST_FOLDER = DATASETS / "iTrust"
    ITRUST_SOLUTION_MATRIX_PATH = ITRUST_FOLDER / "answer_req_javacode.xml"
    ITRUST_REQ_DIR = ITRUST_FOLDER / "req"
    ITRUST_CODE_DIR = ITRUST_FOLDER / "code"
    ITRUST_RAW_CALLGRAPH = ITRUST_FOLDER / "itrust_raw_callgraph.txt"
    ITRUST_CLASS_CALLGRAPH_PATH = ITRUST_FOLDER / "itrust_class_callgraph.json"
    ITRUST_METHOD_CALLGRAPH_PATH = ITRUST_FOLDER / "itrust_method_callgraph.json"
    ITRUST_ALL_CODE_FILENAMES_FILE = ITRUST_FOLDER / "all_code_filenames.txt"
    ITRUST_ALL_REQ_FILENAMES_FILE = ITRUST_FOLDER / "all_req_filenames.txt"
    
    def name(self):
        return "itrust"
    
    def num_original_links(self):
        return 29606
    
    def folder(self):
        return self.ITRUST_FOLDER
    
    def code_folder(self):
        return self.ITRUST_CODE_DIR
    
    def req_folder(self):
        return self.ITRUST_REQ_DIR
    def _all_code_filenames_file(self):
        return self.ITRUST_ALL_CODE_FILENAMES_FILE
    
    def _all_req_filenames_file(self):
        return self.ITRUST_ALL_REQ_FILENAMES_FILE
    def method_callgraph(self):
        return FileUtil.read_dict_from_json(self.ITRUST_METHOD_CALLGRAPH_PATH)
    
    def method_callgraph_path(self):
        return self.ITRUST_METHOD_CALLGRAPH_PATH
    def class_callgraph_path(self):
        return self.ITRUST_CLASS_CALLGRAPH_PATH
    
    def _read_solution_matrix(self):
        self._solution_matrix = read_xml_format_solution_matrix(self.ITRUST_SOLUTION_MATRIX_PATH)
    
    def raw_call_graph_path(self):
        return self.ITRUST_RAW_CALLGRAPH
    
    def class_callgraph(self):
        return FileUtil.read_dict_from_json(self.ITRUST_CLASS_CALLGRAPH_PATH)
    
    def packages(self):
        return ["edu.ncsu.csc.itrust"]


class Smos(Dataset):
    
    SMOS_FOLDER = DATASETS / "smos"
    SMOS_SOLUTION_MATRIX_PATH = SMOS_FOLDER / "UC2CC.csv"
    SMOS_ENGLISH_SOLUTION_MATRIX_PATH = SMOS_FOLDER / "answer_req_code.xml"
    SMOS_REQ_DIR = SMOS_FOLDER / "req"
    SMOS_CODE_DIR = SMOS_FOLDER / "code"
    SMOS_RAW_CALLGRAPH = SMOS_FOLDER / "smos_raw_callgraph.txt"
    SMOS_CLASS_CALLGRAPH_PATH = SMOS_FOLDER / "smos_class_callgraph.json"
    SMOS_METHOD_CALLGRAPH_PATH = SMOS_FOLDER / "smos_method_callgraph.json"
    SMOS_ALL_CODE_FILENAMES_FILE = SMOS_FOLDER / "all_code_filenames.txt"
    SMOS_ALL_REQ_FILENAMES_FILE = SMOS_FOLDER / "all_req_filenames.txt"
    
    UC_NAME_TEMPLATE_REGEX = re.compile("^Nome(:)?", re.RegexFlag.IGNORECASE)
    UC_DESCRIPTION_TEMPLATE_REGEX = re.compile("^Descrizione(:)?", re.RegexFlag.IGNORECASE)
    UC_ACTOR_TEMPLATE_REGEX = re.compile("^Attori(:)?", re.RegexFlag.IGNORECASE)
    UC_PRECONDITION_TEMPLATE_REGEX = re.compile("^Precondizioni(:)?", re.RegexFlag.IGNORECASE)
    UC_POSTCONDITION_TEMPLATE_REGEX = re.compile("^Postcondizioni(:)?", re.RegexFlag.IGNORECASE)
    UC_QUALI_REQ_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE)# should never match -> smos doesn't have this element
    UC_USER_TEMPLATE_REGEX = re.compile("^Utente(:)?", re.RegexFlag.IGNORECASE)
    UC_SYSTEM_TEMPLATE_REGEX = re.compile("^Sistema(:)?", re.RegexFlag.IGNORECASE)
    UC_FLOW_OF_EVENTS_TEMPLATE_REGEX = re.compile("^Sequenza degli eventi(:)?", re.RegexFlag.IGNORECASE)
    
    def name(self):
        return "smos"
    
    def num_original_links(self):
        return 6700
    
    def folder(self):
        return self.SMOS_FOLDER
    
    def code_folder(self):
        return self.SMOS_CODE_DIR
    
    def req_folder(self):
        return self.SMOS_REQ_DIR
    
    def _all_code_filenames_file(self):
        return self.SMOS_ALL_CODE_FILENAMES_FILE
    
    def _all_req_filenames_file(self):
        return self.SMOS_ALL_REQ_FILENAMES_FILE
    
    def method_callgraph(self):
        return FileUtil.read_dict_from_json(self.SMOS_METHOD_CALLGRAPH_PATH)
    
    def method_callgraph_path(self):
        return self.SMOS_METHOD_CALLGRAPH_PATH
    
    def class_callgraph_path(self):
        return self.SMOS_CLASS_CALLGRAPH_PATH
    
    def _read_solution_matrix(self):
        self._solution_matrix = read_txt_format_solution_matrix(self.SMOS_SOLUTION_MATRIX_PATH, delim=",")
    
    def english_solution_matrix(self):
        return read_txt_format_solution_matrix(self.SMOS_ENGLISH_SOLUTION_MATRIX_PATH)
    
    def raw_call_graph_path(self):
        return self.SMOS_RAW_CALLGRAPH
    
    def class_callgraph(self):
        return FileUtil.read_dict_from_json(self.SMOS_CLASS_CALLGRAPH_PATH)
    
    def packages(self):
        return ["smos"]
    
    def encoding(self):
        return "ISO-8859-1"
    
    
class EANCI(Dataset):
    
    EANCI_FOLDER = DATASETS / "eANCI"
    EANCI_SOLUTION_MATRIX_PATH = EANCI_FOLDER / "solution_links.txt"
    EANCI_REQ_DIR = EANCI_FOLDER / "req"
    EANCI_CODE_DIR = EANCI_FOLDER / "code"
    EANCI_RAW_CALLGRAPH = EANCI_FOLDER / "eanci_raw_callgraph.txt"
    EANCI_CLASS_CALLGRAPH_PATH = EANCI_FOLDER / "eanci_class_callgraph.json"
    EANCI_METHOD_CALLGRAPH_PATH = EANCI_FOLDER / "eanci_method_callgraph.json"
    EANCI_ALL_CODE_FILENAMES_FILE = EANCI_FOLDER / "all_code_filenames.txt"
    EANCI_ALL_REQ_FILENAMES_FILE = EANCI_FOLDER / "all_req_filenames.txt"
    
    UC_NAME_TEMPLATE_REGEX = re.compile("^Nome caso d'uso(:)?", flags=re.RegexFlag.IGNORECASE)
    UC_DESCRIPTION_TEMPLATE_REGEX = re.compile("a^", re.RegexFlag.IGNORECASE) # should never match -> eAnci doesn't have this element
    UC_ACTOR_TEMPLATE_REGEX = re.compile("^Attori partecipanti(:)?", re.RegexFlag.IGNORECASE)
    UC_PRECONDITION_TEMPLATE_REGEX = re.compile("^Condizione di entrata(:)?", re.RegexFlag.IGNORECASE)
    UC_POSTCONDITION_TEMPLATE_REGEX = re.compile("^Condizioni di uscita(:)?", re.RegexFlag.IGNORECASE)
    UC_QUALI_REQ_TEMPLATE_REGEX = re.compile("Requisiti di qualita(:)?", re.RegexFlag.IGNORECASE)
    UC_USER_TEMPLATE_REGEX = re.compile("^a^", re.RegexFlag.IGNORECASE)# should never match -> eAnci doesn't have this element
    UC_SYSTEM_TEMPLATE_REGEX = re.compile("^a^", re.RegexFlag.IGNORECASE)# should never match -> eAnci doesn't have this element
    UC_FLOW_OF_EVENTS_TEMPLATE_REGEX = re.compile("^Flusso di eventi(:)?", re.RegexFlag.IGNORECASE)
    
    def name(self):
        return "eanci"
    
    def num_original_links(self):
        return 7645
    
    def folder(self):
        return self.EANCI_FOLDER
    
    def code_folder(self):
        return self.EANCI_CODE_DIR
    
    def req_folder(self):
        return self.EANCI_REQ_DIR
    
    def _all_code_filenames_file(self):
        return self.EANCI_ALL_CODE_FILENAMES_FILE
    
    def _all_req_filenames_file(self):
        return self.EANCI_ALL_REQ_FILENAMES_FILE
    
    def method_callgraph(self):
        return FileUtil.read_dict_from_json(self.EANCI_METHOD_CALLGRAPH_PATH)
    def method_callgraph_path(self):
        return self.EANCI_METHOD_CALLGRAPH_PATH
    
    def class_callgraph_path(self):
        return self.EANCI_CLASS_CALLGRAPH_PATH
    
    def _read_solution_matrix(self, req_ext=None, code_ext=None):
        self._solution_matrix = read_txt_format_solution_matrix(self.EANCI_SOLUTION_MATRIX_PATH, req_ext, code_ext)
    
    def raw_call_graph_path(self):
        return self.EANCI_RAW_CALLGRAPH
    
    def class_callgraph(self):
        return FileUtil.read_dict_from_json(self.EANCI_CLASS_CALLGRAPH_PATH)
    
    def packages(self):
        return ["DB", "Servlet", "Bean"]
        
    def encoding(self):
        return "ISO-8859-1"
    
    
def read_xml_format_solution_matrix(file_path, req_ext=None, code_ext=None):
    """
    Use this for solution matrices of itrust and smos
    """
    document = parse(str(file_path))
    links = document.getElementsByTagName("link")
    tm = SolutionTraceMatrix()
    for link in links:
        req_name = link.firstChild.childNodes[0].data
        code_name = link.lastChild.childNodes[0].data
        tm.add_trace_pair(req_name, code_name)
    return tm

def read_txt_format_solution_matrix(file_path, req_ext=None, code_ext=None, delim=":"):
    """
    Use this for solution matrices of etour, libest, dronology
    """
    
    text_rows = []
    try:
        file = open(file_path, 'r', encoding='utf8')
        text_rows = file.readlines()
    except IOError:
        log.error("Unable to read " + str(file_path))
        
    tm = SolutionTraceMatrix(req_ext, code_ext)
    for row in text_rows:
        row_split = row.split(delim)
        if row_split[1]:
            req_name = row_split[0]
            code_names = row_split[1].split()
            for code_name in code_names:
                tm.add_trace_pair(req_name, code_name)
        
    return tm
