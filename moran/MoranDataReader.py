import logging

from pathlib import Path

from evaluation.Evaluator import F1Evaluator, F1ResultObject, EvalResultObject, \
    MAPEvaluator
from evaluation.SolutionComparator import SolutionComparator
from traceLinkProcessing.TraceLink import TraceLink
from utility import FileUtil

logging.basicConfig(level=logging.INFO,
                    handlers=[logging.FileHandler("log_output.log", mode='w'), logging.StreamHandler()])

log = logging.getLogger(__name__)
MORAN_DATA_FOLDER = Path(__file__).parent / "Data"

"""
Utility class to calculate f1 and MAP from the data of the related work by Moran et al.'s 
"Improving the Effectiveness of Traceability Link Recovery using Hierarchical Bayesian Networks"

Note: Moran et al. evaluated on non-translated. Therefore we need to use the original untranslated
solution matrix.
-> Use Etour(True) instead if Etour() and Smos(True) instead of Smos(). Itrust and Eanci are not affected.

Usage examples

eval_f1_moran_data(MORAN_DATA_FOLDER / "results_RQ1_iTrust_MAP.tm", Smos(True), [0.2, 0.3, 0.4])
eval_f1_moran_data(MORAN_DATA_FOLDER / "results_RQ1_iTrust_MAP.tm", Itrust(), Util.get_range_array(0.1, 0.9, 0.1))

calculate_moran_mean_avg_prec(MORAN_DATA_FOLDER / "results_RQ1_eTour_MAP.tm", Etour(True), None)

"""


def eval_f1_moran_data(file_path, dataset, drop_threshs):
    trace_links = _extract_moran_trace_links(file_path)
    eval_result_list = _eval_moran_data_multiple_thresh(trace_links, dataset, drop_threshs)
    best = None
    best_thresh = None
    for eval_result_object, thresh in eval_result_list:
        log.info(f"\n drop_thresh={thresh}:\n" + eval_result_object.get_print_str() + "\n")
        if not best or eval_result_object.is_greater_than(best):
            best = eval_result_object
            best_thresh = thresh
    log.info(f"\nBest f1 at {best_thresh}: \n{best.get_defining_value()}")


def convert_moran_to_recall_prec_csv(file_path, dataset, drop_threshs, output_file_name):
    """
    Creates a csv file with recall/precision pairs that are generated by applying the thresholds.
    e. g. drop_threshs = [0, 0.01, 0.02, ..., 1]
    The csv file can be used to illustrate a recall/precision graph in LaTex.
    """
    trace_links = _extract_moran_trace_links(file_path)
    eval_result_list = _eval_moran_data_multiple_thresh(trace_links, dataset, drop_threshs)
    recall_prec_dict = {}
    for eval_result_object, _ in eval_result_list:
        if  isinstance(eval_result_object, F1ResultObject):
            recall_prec_dict[eval_result_object.recall] = eval_result_object.precision
    
    FileUtil.write_recall_precision_csv(recall_prec_dict, output_file_name)

    
def calculate_moran_mean_avg_prec(file_path, dataset, k):
    """
    MAP @ k
    Use k = None to get MAP@All (No cut after k)
    """
    trace_links = _extract_moran_trace_links(file_path)
    map_result_object = MAPEvaluator(SolutionComparator(dataset.solution_matrix()), dataset.all_original_req_file_names(),
                                            dataset.all_original_code_file_names(), False, True, k).evaluate(trace_links)
    log.info(f"{map_result_object.get_print_str()}")
    
    
def _eval_moran_data_multiple_thresh(trace_links, dataset, drop_threshs) -> [(EvalResultObject, float)]:
    return [(_eval_moran_data_at_thresh(trace_links, dataset, thresh), thresh)  for thresh in drop_threshs]

        
def _eval_moran_data_at_thresh(trace_links, dataset, drop_thresh) -> EvalResultObject:
    trace_links = [link for link in trace_links if link.similarity > drop_thresh]
    return F1Evaluator(SolutionComparator(dataset.solution_matrix())).evaluate(trace_links)


def _extract_moran_trace_links(file_path):
    lines = FileUtil.read_textfile_into_lines_list(file_path)
    lines = lines[6:]  # first 6 lines contain no similarity data
    trace_links = []
    for line in lines:
        req, code, sim = line.split(" ")
        code = _remove_package_prefix(code)
        if code.endswith(".jsp") or  code.endswith(".txt"):
            continue
        sim = float(sim)
        trace_links.append(TraceLink(req, code, sim))
    return trace_links

            
def _remove_package_prefix(name):
    if name.count(".") > 1:
        parts = name.split(".")
        name = parts[-2] + "." + parts[-1]  # Last dot is for file extension
    return name

